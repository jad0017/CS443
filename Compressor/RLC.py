import math
# Local imports
import Matrix

# This was generated by the following get_RLC_translation_matrix
# function.
# TODO: Make this a dictionary cache.
RLC_Tp8 = [
    (0,0),
    (0,1), (1,0),
    (2,0), (1,1), (0,2),
    (0,3), (1,2), (2,1), (3,0),
    (4,0), (3,1), (2,2), (1,3), (0,4),
    (0,5), (1,4), (2,3), (3,2), (4,1), (5,0),
    (6,0), (5,1), (4,2), (3,3), (2,4), (1,5), (0,6),
    (0,7), (1,6), (2,5), (3,4), (4,3), (5,2), (6,1), (7,0),
    (1,7), (2,6), (3,5), (4,4), (5,3), (6,2), (7,1),
    (7,2), (6,3), (5,4), (4,5), (3,6), (2,7),
    (3,7), (4,6), (5,5), (6,4), (7,3),
    (7,4), (6,5), (5,6), (4,7),
    (5,7), (6,6), (7,5),
    (7,6), (6,7),
    (7,7)
]


def gen_RLC_translation_array(N):
    """
    Returns an array used for translating from
    array indices to matrix coordinates for
    the Zig-Zag pattern used by this module's
    method of Run-Length Coding.

    :param N:
        Number of sides for the RLC matrix.

    :returns:
        The generated array for the given
        side length, :param N:.
    """
    # Format: ( y, x )
    t = (0,0)
    out = [ (0,0) ]
    # Traverse the first half of the matrix (1's):
    #
    # [ 1 1 1 1 1 ]
    # [ 1 1 1 1 2 ]
    # [ 1 1 1 2 2 ]
    # [ 1 1 2 2 2 ]
    # [ 1 2 2 2 2 ]
    for x in range(0, N - 1):
        # When x is even or zero, we
        # snake the right edge of the
        # matrix.
        if (x & 1) == 0:
            # Go right.
            t = ( t[0], t[1] + 1 )
            # Swap of t.  This is the "target"
            # to reach when traversing in the
            # following while loop.
            o = ( t[1], t[0] )
            out.append(t)
            # Traverse to the left edge from
            # the top at a diagonal relative
            # to the top left corner.
            while t != o:
                t = ( t[0] + 1, t[1] - 1 )
                out.append(t)
        # When x is odd, we snake the
        # left edge of the matrix.
        else:
            # Goin' dowwwwn.
            t = ( t[0] + 1, t[1] )
            o = ( t[1], t[0] )
            out.append(t)
            # Traverse to the top edge from
            # the left at a diagonal.
            while t != o:
                t = ( t[0] - 1, t[1] + 1 )
                out.append(t)
    # Round 2: Traverse the second half of
    # the earlier matrix (2's).
    if t[1] == 0:
        # When given an even edge-length,
        # t ends on a different format than
        # we need for performing the lower-half
        # conversion.
        t = ( t[1], t[0] )
    for x in range(0, N - 1):
        # For this round, when x is even or zero,
        # we traverse the right edge.
        if ( x & 1 ) == 0:
            # Move up the right side.
            t = ( t[0] + 1, t[1] )
            o = ( t[1], t[0] )
            out.append(t)
            # Traverse to the bottom edge from
            # the right at a diagonal relative
            # to the bottom right corner.
            while t != o:
                t = ( t[0] + 1, t[1] - 1 )
                out.append(t)
        # When x is odd, we snake the bottom
        # edge of the matrix.
        else:
            # Move right across the bottom edge.
            t = ( t[0], t[1] + 1 )
            o = ( t[1], t[0] )
            out.append(t)
            # Traverse to the right edge from
            # the bottom at a diagonal.
            while t != o:
                t = ( t[0] - 1, t[1] + 1)
                out.append(t)
    # Return the resultant array.
    return out


def RLC(C):
    """
    Perform Zig-Zag Run-Length Coding on a given matrix.

    :param C:
        Matrix to perform RLC on.  Must be square!

    :returns:
        An array of tuples in the following form:
        [ (count0, value0), (count1, value1), ... , (countN, valueN) ]
    """
    # Generated from the given matrix (C)'s edge length.
    if len(C) == 8:
        # Use the pre-generated array for 8.
        # It's faster...
        global RLC_Tp8
        R = RLC_Tp8
    else:
        R = gen_RLC_translation_array(len(C))
    # Return array
    a = []
    current = C[0][0]
    count = 0
    for i in range(len(R)):
        (y,x) = R[i]
        if C[y][x] == current:
            count += 1
        else:
            # Finished length of the current symbol,
            # switch to the next symbol.
            a.append( (count, current) )
            current = C[y][x]
            count = 1
    # Make sure the final item is added to the list.
    a.append( (count, current) )
    return a


def iRLC(a, N=0):
    """
    Perform the Inverse of the :function RLC: function.

    :param a:
        Array of tuples of the following form:
        [ (count0, value0, (count1, value1), ... , (countN, valueN) ]

    :param N:
        Optionally, supply the resultant edge length to avoid additional
        processing.

    :returns:
        A matrix expanded from the input array.
    """
    # If no length is given, derive it from the input.
    if N <= 0:
        tN = 0
        for i in range(len(a)):
            tN += a[i][0];
        tN = int(math.sqrt(tN))
    else:
        tN = N
    # Generate the translation matrix, or just
    # grab the pre-generated for an edge-length
    # of 8.
    if tN == 8:
        global RLC_Tp8
        R = RLC_Tp8
    else:
        R = gen_RLC_translation_array(tN)
    # Return matrix
    A = Matrix.zero_square_matrix(tN)
    idx = 0
    for i in range(len(a)):
        (count, value) = a[i]
        # Drop the value for the given
        # count.
        for j in range(count):
            (y, x) = R[idx]
            idx += 1
            A[y][x] = value
    return A


# vim: ts=4:sw=4:sts=4:et:ai
